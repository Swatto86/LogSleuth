# LogSleuth Format Profile: Plain Text (Fallback)
#
# Assigned to files that match no other format profile.
# No timestamp or level extraction; every line becomes a standalone entry.
# The file is still fully searchable via text/regex filters.
#
# This profile should never win auto-detection over a more specific profile
# because its content_match matches any non-empty line.

[profile]
id = "plain-text"
name = "Plain Text (Unstructured)"
version = "1.0"
description = "Fallback for files with no recognised log format. Full-text search only."
log_locations = [
    "Generic fallback - matches any text file not claimed by another profile",
]

[detection]
file_patterns = []
# Matches any non-empty, non-whitespace line
content_match = '\S'

[parsing]
# Entire line is the message; no timestamp, level, or other fields extracted
line_pattern = '^(?P<message>.+)$'
# Unused but required by schema
timestamp_format = "%Y-%m-%d %H:%M:%S"
multiline_mode = "raw"

[severity_mapping]
critical = ["CRITICAL", "FATAL"]
error = ["ERROR", "FAIL", "FAILED", "Exception"]
warning = ["WARNING", "WARN"]
info = []
debug = []

# Regex-based severity override: applied before keyword substring matching.
# These patterns use regex precision to catch common bracket-style markers
# (e.g. [ERR], [CRITICAL]) and Java-style exception class names that the
# plain string mapping might miss or over-broadly match.
[severity_override]
critical = ['\[CRIT(ICAL)?\]', '\[FATAL\]', '\bFatalException\b']
error    = ['\[ERR(OR)?\]', '\bException\b', '\bStackTrace\b', '\bUnhandled\b']
warning  = ['\[WARN(ING)?\]', '\bDeprecated\b']
info     = ['\[INFO(RMATION)?\]']
debug    = ['\[DEBUG\]', '\[VERBOSE\]', '\[TRACE\]']
